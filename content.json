{"meta":{"title":"文以致远","subtitle":"我长辨他人是非，却难辨自己真假。","description":null,"author":"Yaning.Dou","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-07-16T13:23:47.000Z","updated":"2017-07-16T13:24:31.930Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"本文链接：&lt;%= post.title %&gt; 作者：blackcloud2333 出处：http://jiji262.github.io/本文基于 知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名blackcloud2333及链接。"}],"posts":[{"title":"es5和es6当中的继承","slug":"es5和es6当中的继承","date":"2017-07-30T10:55:02.000Z","updated":"2017-07-30T12:28:44.510Z","comments":true,"path":"2017/07/30/es5和es6当中的继承/","link":"","permalink":"http://yoursite.com/2017/07/30/es5和es6当中的继承/","excerpt":"","text":"##es5中的继承es5中的继承分很多种，在这里我就不赘述了，网上有很多的讲有关这些的教程我在这里推荐一篇https://juejin.im/post/5912753ba22b9d005817524e我个人认为方式最好的也是最常见的是寄生式继承也就形式上大概像下面的这种 /寄生组合继承特点:同时继承子类的构造函数和原型中的属性 /function Person (name) { this.name= name; this.className = ‘Person’;}Person.prototype.getName =function() { console.log(this.name);}function Man(name){ Person.apply(this,arguments);}//寄生组合继承，就是先创造一个新的man.prototyped对象然后关联到person.prototype//实现了对person.prototype的浅拷贝Man.prototype = Object.create(Person.prototype); var man1 = new Man(‘David1’);console.log(man1.name);这样的大概是我个人看到的最多的一种继承方式了，这种继承的方式感觉和父类和子类之间构筑了一层隔离物能子类能继承父类，但是又不会影响父类，感觉就很nice。1 this是我认为es6继承和es5继承中殊途同归的一个点（虽然ES6中的class本来就是语法糖）但是ES6当中constructor中的的this就可以看成是类自身的实例对象，给人的感觉更好理解，或者说更贴近于java当中的继承的形式，反正就是语法糖吃起来很甜，但是最终还是殊途同归最终还是要看到其实都是在this上添加各种的属性。2 方法是我认为的第二个语法糖吃起来比较甜的第二个地方，因为ES6中虽然还是把方法放到prototype上面去，但是写起来就很舒服（虽然仍然没有解决私有方法的问题），私有方法我个人还是喜欢写到类的外面去，但是阮一峰的的ES6入门也推荐了一种就是__move()类似这种形式。3 方法屏蔽问题 ，不管在ES5 还是ES6中都没有解决。方法屏蔽：如果子类和父类中都有这样的一种方法，那么在new一个新的对象的时候都会首先在子类上面去找，如果找到了就用子类的，如果找不到，就去父类中找，还找不到就去祖先类中找，还找不到就去顺着原型链一直找到Object.prototype，如果还找不到那么就会抛出undefined。但是怎么解决这个问题呢？这个是我在学习当中遇到的一个问题。解决的方法无非分几种 1 如果确实存在父类和子类同名的方法又想用父类的，那么有一个选择就是new一个父类对象，然后再new一个子类对象，然后分别对两个方法传参就像下面这种 function Person (name,age) { this.name = name; this.age = age;}Person.prototype.toString = function () { return ‘i am a person my name is ‘+ this.name;}function Man(name,age) { Person.apply(this,arguments);}Man.prototype = Object.create(Person.prototype);Man.prototype.toString = function () { return ‘ i am a man , and my name is ‘+this.name;}var person = new Person(‘he’,19);var man1 = new Man(‘David’,18);var man2 = new Man(‘jack’,20);console.log(man1+’’);console.log(person+’’);console.log(man1","categories":[],"tags":[]},{"title":"异步加载","slug":"异步加载","date":"2017-07-19T13:13:21.000Z","updated":"2017-07-19T13:13:21.886Z","comments":true,"path":"2017/07/19/异步加载/","link":"","permalink":"http://yoursite.com/2017/07/19/异步加载/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"js当中的内存泄泄漏","slug":"js当中的内存泄泄漏","date":"2017-07-16T07:14:44.000Z","updated":"2017-07-18T12:08:00.038Z","comments":true,"path":"2017/07/16/js当中的内存泄泄漏/","link":"","permalink":"http://yoursite.com/2017/07/16/js当中的内存泄泄漏/","excerpt":"","text":"##常见的内存泄漏的情景1 ###意外的全局变量js当中当全局的变量用于存储大量的信息的时候，需要更加的小心，在用完之后要设置为null或者重新进行定义，和全局变量相关增加内存消耗的一个显著的原因就是缓存，但是高内存很可能导致缓存上限。缓存数据是为了保证重用。2 ###被遗忘的计数器或者回调函数，如果计时器用完之后无法被及时的回收，那么也会导致这些问题。3 ###脱离DOM的引用","categories":[],"tags":[]},{"title":"ajax请求的时候get和post的区别","slug":"ajax请求的时候get和post的区别","date":"2017-07-16T06:44:36.000Z","updated":"2017-07-16T07:12:02.790Z","comments":true,"path":"2017/07/16/ajax请求的时候get和post的区别/","link":"","permalink":"http://yoursite.com/2017/07/16/ajax请求的时候get和post的区别/","excerpt":"","text":"1 get的请求要注意缓存问题，post完全的不用担心2 post请求必须设置content-type的值为application/x-form-www-urlencoded3 发送请求的时候因为get请求的参数都在URL里面，所以send的函数发送的参数为null，而post使用send方法的时候要赋予其参数。4 使用get的时候，参数在url中显示，但是使用post方式就不会显示出来。5 使用get发送的数据量比较小，但是使用post发送的数量比较大。 ##服务器端请求的区别在客户端使用get的时候服务器端使用使用RePost.QueryString 来获取参数。当客户端使用post的时候，服务端使用的是Request.Form来获取 参数。关于服务器端获取数据我们还可以使用一个通用的获取数据的方式Request[‘username’]；(1)从请求的URL可以看出来get是带着参数的，post请求的URL则不带。(2)从cache可以看出来，get请求在发送之后就会被立即的缓存，但是post的请求无缓存。(3)从post Data里面大概的可以看出因为git请求的字符串是在URL中附带的，所以postData中无数据。 ##总结：(1)GET：会把数据添加到URL里面，通过这种方式传递到服务器。通常是用的一个问号？来代表URL地址的结尾和参数的开端，后面参数的每一个数据参数都以key:value的形式出现参数和参数之间用&amp;来区分(传值只需要参数的时候用get)(2)POST：数据放在HTTP主体当中的，组织方式不止一种，也有&amp;连接方式，也有分割符的连接方式，可以隐藏参数，传递大批量的数据，较为方便。(用于提交表单和传送较大文件)。","categories":[],"tags":[]},{"title":"js当中的对象","slug":"js当中的对象","date":"2017-07-16T02:07:54.000Z","updated":"2017-07-18T12:08:01.068Z","comments":true,"path":"2017/07/16/js当中的对象/","link":"","permalink":"http://yoursite.com/2017/07/16/js当中的对象/","excerpt":"","text":"1 js当中对象的内容并不是储存在对象内部的，对象内部保存的属性值相当于一个引用（指针），用于引用把指向真正存储值的位置。 var myobject = { value:2;}value就相当于一个指针，指向真正存储的位置。2 对象中属性名永远都是字符串，即使使用其他的类型，也会优先尝试转化为字符串。然后在做运算和赋值。","categories":[],"tags":[]},{"title":"new运算符到底做了什么？","slug":"new运算符到底做了什么？","date":"2017-07-16T01:47:22.000Z","updated":"2017-07-16T02:08:10.646Z","comments":true,"path":"2017/07/16/new运算符到底做了什么？/","link":"","permalink":"http://yoursite.com/2017/07/16/new运算符到底做了什么？/","excerpt":"","text":"前面看《你不知道的JS》的时候突然看到了这个问题，感觉也很有意义就去研究了下。1 创建一个全新的对象2 这个新对象会被执行[[Prototype]]连接3 这个新对象会被绑定到函数调用的this4 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象听起来很抽象。","categories":[],"tags":[]},{"title":"刷题总结1 返回拓展名","slug":"刷题总结1-返回拓展名","date":"2017-07-07T14:00:50.000Z","updated":"2017-07-09T12:45:30.305Z","comments":true,"path":"2017/07/07/刷题总结1-返回拓展名/","link":"","permalink":"http://yoursite.com/2017/07/07/刷题总结1-返回拓展名/","excerpt":"","text":"完成 extname 函数，它会接受一个文件名作为参数，你需要返回它的扩展名。 例如，输入 emoji.png，返回 .png。 这个题看似很简单，但是实际上，却有坑，主要就是体现在边界条件上。看过题的人大概都有个想法：这不是很简单吗，按照点来切割不就行了吗？如果有兴趣的话，可以自己试试。下面是在线测试的地址 https://scriptoj.com/测试完之后我相信很多人一遍甚至两次提交都没法通过。所以我愈发的觉得边界条件是一个程序稳定性的保证。下面是我个人写的两种解决方案第一种解决方案 const extname = (filename) =&gt; { / TODO / let i ; const len = filename.length; for(i=len-1;i&gt;=0;i–) { if(filename[i] === ‘.’&amp;&amp;i!=0) { return filename.substring(i,len); } } return ‘’;}第二种解决方案 const extname = (filename) =&gt; { / TODO / var len = filename.length; if(filename[0] === ‘.’ || filename[len-1] === ‘.’ || filename.includes(‘.’) === false ) return “”; for(i=len-1;i&gt;=0 ;i –) { if(filename[i] === ‘.’){ return filename.slice(i, len); } }}我觉得应该还是有第三种解决方案的(正则)但是有一个最重要情况是我第一次提交没有考虑到的:’hell0.ab.cd.jpg’，像这样的测试用例，是很容易被忽略的，另外本身这个测试还存在着一定的问题就是’12233.jpg’，这种测试用例明明在本地是跑不通的，但是在线跑就没问题，这个是这个题目的测试用例本身写的有问题的地方。上面的第一个测试用例就决定了在进行遍历的时候一定是不能从0-len-1这样进行遍历的，否则会陷入自己觉得明明没错但是实际却通过不了的困境。","categories":[],"tags":[]},{"title":"leetcode#35. Search Insert Position","slug":"leetcode-35-Search-Insert-Position","date":"2017-06-18T13:16:26.000Z","updated":"2017-06-18T13:23:49.190Z","comments":true,"path":"2017/06/18/leetcode-35-Search-Insert-Position/","link":"","permalink":"http://yoursite.com/2017/06/18/leetcode-35-Search-Insert-Position/","excerpt":"","text":"Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 Subscribe to see which companies asked this question.题干的意思大致上是说，在数组当中进行搜索如果target的话，那么找出target，如果没有的话就把target插入进去，并且找出来插入的位置。 var searchInsert = function(nums, target) { if(nums!==””&amp;&amp;target!==””){ if(nums.indexOf(target)!==-1){ return nums.indexOf(target); }else{ nums.push(target); nums.sort(function(a,b){ return a-b; }); return nums.indexOf(target); } }else{ return 0; }};上面是accepted的，但是感觉很麻烦，主要是今天发现了一个忽略很久的东西，sort()我一直以为是按照数值大小排序的然而并不是而是按照Unicode码进行排序的，所以如果出现了10这个数字，就会发生异常，直接使用sort()很有可能是10出现在最前面，所以明显不对，解决方案就是在sort里面写一个比较函数 arr.sort(function(a,b){ return a-b; })这样的话，那么就实现了对arr的按照数字大小进行排序。当然这道题还有其他更简单的解决方案，后面二刷的时候再来继续补充。","categories":[],"tags":[]},{"title":"##leetcode28 Implement strStr","slug":"leetcode28-Implement-strStr","date":"2017-06-14T12:54:59.000Z","updated":"2017-06-14T13:09:53.214Z","comments":true,"path":"2017/06/14/leetcode28-Implement-strStr/","link":"","permalink":"http://yoursite.com/2017/06/14/leetcode28-Implement-strStr/","excerpt":"","text":"Implement strStr().题干Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.意思就是找出needle字符串在haystack字符串当中第一次出现的index.下面是accepted的代码： var strStr = function(haystack, needle) { if(haystack===””&amp;&amp;needle!==””) { return -1; } if(haystack===””&amp;&amp;needle===””){ return 0; } if(haystack!==””&amp;&amp;needle===””){ return 0; } if(haystack!==””){ return haystack.indexOf(needle); }else{ return -1; } };震惊！，第一次竟然accepted了，但是感觉好像有点low，于是乎我就去看了看还有没有其他的方法当然是有的。 Array.prototype.indexOf = function (str) {for (var i = 0; i &lt; this.length; i++) {if (str == this[i]) {return i; } }return -1;} 上面的是indexOf实现的源码，几乎所有的其他的方法基本上都是围绕这个来的，当然有一种除外(正则)；ES6当中有contains这样的一种方法也可以判断到底X在不在Y当中，但是没办法判断到底index是多少。 function isContains(str, substr) { return str.contains(substr);}实现原理大概就是这样，但是正则的自己还没彻底弄明白，正好前几天面试也面到了这类题，等后面整理好了再来补充。","categories":[],"tags":[]},{"title":"leetcode7 removeElement.md","slug":"leetcode27-removeElement-md","date":"2017-06-07T07:02:07.000Z","updated":"2017-06-07T07:17:31.476Z","comments":true,"path":"2017/06/07/leetcode27-removeElement-md/","link":"","permalink":"http://yoursite.com/2017/06/07/leetcode27-removeElement-md/","excerpt":"","text":"##leetcode7 remove Element现在目标是先把leetcode上面easy的题目先刷一遍，所以刷题的顺序有点跳跃，但是慢慢的都会补上的。Given an array and a value, remove all instances of that value in place and return the new length.Do not allocate extra space for another array, you must do this in place with constant memory.The order of elements can be changed. It doesn’t matter what you leave beyond the new length.Example: Given input array nums = [3,2,2,3], val = 3Your function should return length = 2, with the first two elements of nums being 2.删除某个数组当中所有指定的某个数字，返回删除完特定数字之后的数组的长度。(下面的思路是不考虑新开数组的前提下，也尝试了新开数组的方法也可以，但是leetcode，没办法accept(摊手)，所以暂时就先拿这个了)思路：删除val首先要做一遍遍历，for一次，拿到所有的本数组中所有的元素，然后依次和已知的val比一下，然后如果不相等那么就用现在的这个值覆盖nums前面的值，最后输出数组的长度就OK了. var removeElement = function(nums, val) { var len=nums.length; if(len===0) return len; var count=0; for(var i=0;i&lt; len;i++){ if(nums[i]!==val){ nums[count++]=nums[i]; } } return count;};暂时这样写是被accept的，但是边界检查总感觉少了点什么，感觉会是一个坑，不过后面还会再刷，那时候再来补充吧。另外，return的时候，不能return nums.length，因为存在着作用域的问题，直接在最外层returnnums的时候依然会return到的值是前面未经改变过的nums的值。当然实在想返回nums.length的话，应该也行，但是前面的代码要大改，不能这样使用，等完成之后再来补充吧。","categories":[],"tags":[]},{"title":"letcode#1 twosum","slug":"leetcode1-twoSum","date":"2017-05-31T13:29:38.000Z","updated":"2017-06-07T07:17:33.076Z","comments":true,"path":"2017/05/31/leetcode1-twoSum/","link":"","permalink":"http://yoursite.com/2017/05/31/leetcode1-twoSum/","excerpt":"","text":"今天第一次正式的刷算法题，然后被letcode上的一个相当简单的问题给搞了一下Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].Subscribe to see which companies asked this question.大致上就是说要求：给了一个target，然后让你在数组里面找出x+y=target中x,y的下标。常见的思路：暴力查询： var twoSum = function(nums, target) { var i,len = nums.length; for (i=0;i &lt; len-1;i++) { for (j=i+1;j &lt; len;j++) { if (nums[i] + nums[j] === target) { return [i,j]; } } }}; 然后提交之后没办法通过，大概意思是用的方法太蠢了，时间复杂度太高。 想了一下时间复杂度O(n^2),的确有点高。 第二种方法就是hash了，利用map来一边查询一边result推进hash表当中 首先理解思路： 先遍历一遍整个数组确认能拿到每一个值 然后result=target-nums[i]; 得到result，如果在hash表当已经有了result，那么直接输出map当中result对应的value(相应的数组下标); 如果hash表当中没有相应的result，比如5(result)=8(target)-3(num[0]) 存的时候要存一种key:value的形式，map[num[i]]=i;(因为最后需要的是下标); var twoSum = function(nums, target) { var map = {}; for(var i = 0 ; i &lt; nums.length ; i++){ var v = nums[i]; if(map[target-v] &gt;= 0){ target = x + v return [map[target-v],i] } else { map[v] = i; } }}; 当然使用hash也是一样的道理。 很重要:推进hash/map当中的是nums[i],不是result; 2017.6.6追加 刚刚刷一道数组去重的问题的时候也发现了一个问题，数组去重问题用一种类似hash的结构也可以完美的解决，而且时间复杂度比暴力检索要好的多arr=[1,5,2,5,5,8,2];一个无序的数组。如果是暴力检索，的话 var removeDup = function(arr){ var res=[]; for(var i=0; i&lt; arr.length;i++){ for( var j=i+1; j&lt; arr.length ;j++){ if(arr[i]===arr[j]){ j=++i; } } res.push(arr[i]); } return res;}console.log(removeDup([1,2,5,1,6]));但是这样的方法的确是有点蠢，于是苦思冥想，觉得这个解决方案和第一个twosum解决方案完全是相似的 var remove=function(arr){ var res=[]; var hash={}; for(var i=0;i&lt; arr.length;i++){ if(!hash[arr[i]]){ res.push(arr[i]); hash[arr[i]]=1; } } return res;}console.log(remove([1,5,2,5,5,8,2]));两个题的思路都是依靠一个key:value;来达到一种利用hash查询的功能，即利用已有的数组中的值和hash当中的值进行比较得出到底有没有重复出现的值，前面是获取到这个值拿来用，后者是排除到这个值。但是这种方法依然是存在着不少的问题的具体的，可以看这个篇文章，本人认为这篇文章写得很棒也很全面。Google","categories":[],"tags":[]},{"title":"webpack1和webpack2的坑","slug":"webpack1和webpack2的坑","date":"2017-04-19T12:43:04.000Z","updated":"2017-04-19T13:51:58.660Z","comments":true,"path":"2017/04/19/webpack1和webpack2的坑/","link":"","permalink":"http://yoursite.com/2017/04/19/webpack1和webpack2的坑/","excerpt":"","text":"第一坑：绝对路径未定义，webpack1和webpack2是不一样的。等下去找官网看解决方法：const path = require(‘path’);module.exports = { entry:’./src/script/main.js’, output: { path: path.resolve(__dirname, ‘./dist/js’), filename: ‘bundle.js’ }}这样就行了第二个坑var htmlWebpackPlugin = require (‘html-webpack-plugin’);然后在html模板中写的时候&lt;% = htmlWebpackPlugin %&gt;上面的ejs语法当中必须用驼峰式写法否则就会报错。 第三个坑还是关于ejs语法的在ejs中写js的时候每一行一行都要以这样的&lt;% %&gt;形式否则就会报错，而且一个问题就是&lt;%= %&gt;这里的这个等于一定要紧紧的靠着第一个%否则也会报错。","categories":[],"tags":[]},{"title":"双飞翼布局","slug":"双飞翼布局","date":"2017-04-07T13:44:01.000Z","updated":"2017-06-11T13:51:54.875Z","comments":true,"path":"2017/04/07/双飞翼布局/","link":"","permalink":"http://yoursite.com/2017/04/07/双飞翼布局/","excerpt":"","text":"圣杯布局最近在温习css的基础知识，发现好多都忘了，正好拿这两个经典的布局来练手，同时发现一些问题，现在再来总结一次。其实无论是双飞翼布局还是圣杯布局从表面上看其实都是常见的三列布局。其实最难的不是布局本身的思想，而是对背后position和float的不理解。（1）开始第一步，重置。清除所有默认格式是每一个了解切图的人的第一感觉。 {margin：0;padding:0;} 强烈不推荐上面的这种写法，但是为了简单，就这样写了先。（2）正式主体部分开始大部分的萌新，心里其实也都有数，既然三列布局肯定是涉及到浮动的问题，或者下意识的想到了全部左浮动。为了看清楚给所有的盒子都染了颜色 { margin:0;padding:0;}article .center，.left， .right { float: left;}article .center { width: 100%; background-color: red;}article .left { width: 200px; height: 120px; background-color: green;}article .right { width: 120px; height: 120px; background-color: yellow;}初步的成果可能代码就写成这样了但是明显不符合我们的要求，为什么呢，因为width设置了100%，然后全部左浮动的结果就是所有的都所有的都变成了块级元素,然后一个个的排列着，所以出现这种情况，那么怎么解决呢？margin的负值是一个很好的解决方法，但是在解决之前要先说下总体的圣杯布局和双飞翼布局的思路。两种布局的思路都是先把center部分固定到指定的位置，然后再对左右两侧进行固定。所以这里要先把左右需要的先预留出来因此要给一部分padding给左右两侧 .container { overflow:hidden; zoom:1; padding:0 120px 0 200px;}接下来就出现了这种情况接下来就是让左边的向左先移到窗口的边缘部分然后再想办法把左边部分“推”上去。右边部分也一样，因此 *{ margin:0;padding:0;} .container { overflow:hidden; zoom:1; padding:0 120px 0 200px; }article .center，.left， .right { float: left;}article .center { width: 100%; background-color: red;}article .left { width: 200px; height: 120px; left:-200px; background-color: green;}article .right { width: 120px; height: 120px; left:120px; background-color: yellow;}上面的left:-200px;对绝对定位的元素，是到包含块左侧边缘的距离对相对定位的原件，如果原件在未定位的情况下从正常流中的位置离开的偏移。而对于left块就是要先把它偏移到左边。同时要设置margin-left为负值，把margin-left设置成负值就相当于把left块向右挤了一部分，这样就可以把左侧的“推”上去。同样的想把右侧的“推”上去，就得先把right块脱离流，然后才能推上去margin-left:-120px;//本身的长度这样才能完成相应的布局。 双飞翼布局双飞翼布局相对来说会好很多，主要就是为center添加了一个壳子，相当于不用container去留空间了，直接在center的壳子和center之间开空间就能为左右两侧的块腾出位置了 # main {overflow: hidden;zoom: 1;background-color: #eee;}/*这里不需要加padding了*/ . m_content , . m_leftside, . m_rightside {float: left;} . m_content {width: 100%;} /*用左右边距将左右边栏的位置预留出来*/ . m_c_wrap {margin-left: 220px;margin-right:300px; background-color: red;} . m_leftside {width: 220px;margin-left: -100%;background-color: green;} . m_rightside {width: 300px;margin-left: -300px;background-color: orange;} . self-box { width: 80px; height: 80px; margin:20px; } 实际的效果如下图就是这样了，而且还形成了三列等高，相当于把左右俩块挤到container两侧。","categories":[],"tags":[]},{"title":"express（1）","slug":"express（1）","date":"2017-03-28T12:59:31.000Z","updated":"2017-03-28T13:57:58.511Z","comments":true,"path":"2017/03/28/express（1）/","link":"","permalink":"http://yoursite.com/2017/03/28/express（1）/","excerpt":"","text":"####应用层中间件var express= require(‘express’);var app=express;app.MEHTOD(‘path’,function () { });path:path可以是字符串，字符串模式，正则表达式。中间件函数能访问函数能够访问请求对象(req)，相应对象(res)以及应用请求/响应循环的下一个中间件函数。下一个中间件函数通常由名为next的变量来表示。中间件函数作用：执行任何代码。对请求和响应对象进行更改。结束请求/响应循环。调用堆栈中的下一个中间件函数。应用层中间件实例：var app=express;app.get(‘/user/:id’,function(req,res,next) { res.send(‘user’);})路由及中间件系统，针对路径发来的get请求跳过路由器中间件堆栈中剩余的中间件函数，调用next(‘route’) ####路由层中间件var router = express.Router();var app =express();router.use(function (req,res,next) { });router.get(‘/user/:id’,function (req,res,next) { }); ####错误处理中间件比前面的多一个特征符app.use(function (err,req,res,next) { console.error(err.stack); res.status(500).send(‘something broke!’)}); ####内置中间件自v4.x起，Express不再支持connect，除了express.static外 第三方组件先使用npm安装$ npm install cookie-parservar express= require(‘express’);var app=exress;var cookieParser = require(‘cookie-parser’);app.use(cookieParser()); express.Router()使用express.router类来创建可安装的模块化路由处理程序，Router实例是完整的中间件和路由系统var express = require(‘express’);var router =express.Router();router.use(function timeLog (req,res,next) { console.log(‘time’,Date.now()); next();});router.get(‘/‘,function (req,res) { res.send(‘bird home page’);});router.get(‘/about’,function (req,res,) { res.send(‘about birds’);})module.exports = router;var birds = require(‘./birds’);app.use(‘/birds’,birds);","categories":[],"tags":[]},{"title":"欠债还钱系列（2）不得不面对的闭包","slug":"欠债还钱系列（2）不得不面对的闭包","date":"2017-03-22T13:31:57.000Z","updated":"2017-03-22T14:02:08.704Z","comments":true,"path":"2017/03/22/欠债还钱系列（2）不得不面对的闭包/","link":"","permalink":"http://yoursite.com/2017/03/22/欠债还钱系列（2）不得不面对的闭包/","excerpt":"","text":"闭包是每个学JS的人不得不面对的一个问题，前几天听芋头大大的知乎live的时候正好提了一下他们公司的几个面试实习生的看重的几个方面，以及一些能力，顺便给了一下他们实习生面试的题目。然后我就去做了一下，结果发现自己还真的是有一些不会的比如.闭包 下面五段代码分别输出什么？并且什么时候输出什么？for(var i = 0; i &lt; 5; i++) { console.log(i);}for(var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(i); }, 1000 i);}for(var i = 0; i &lt; 5; i++) { (function(i) { setTimeout(function() { console.log(i); }, i 1000); })(i);}for(var i = 0; i &lt; 5; i++) { (function() { setTimeout(function() { console.log(i); }, i 1000); })(i);}for(var i = 0; i &lt; 5; i++) { setTimeout((function(i) { console.log(i); })(i), i 1000);}这道题就是很经典的闭包的面试题，以及他的几个变种，但是核心来讲还是闭包的问题。闭包：一个有权访问另一个函数作用域的函数。前两道，相信大家都看烂了，所以也不多表，在这里我想说的是第三道，这个涉及了IIFE,闭包，js的单线程，以及匿名函数的作用域等问题。关于这道题的IIFE（立即执行函数）(function(i) { setTimeout(function() { console.log(i); }, i 1000); })(i); 上面的其实可以这样写 (function(i) { setTimeout(function() { console.log(i); }, i 1000); })； (i);这样写可能比较好理解，也即是先声明了一个函数表达式，后面的调用这个函数表达式，并且把i传进函数表达式。而且函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被立即传递。一个立即调用的函数表达式可以锁定当时的状态。因此这样函数表达式外的i就可以顺利的被括号内的function调用和访问了，这样就实现了闭包。如果你不理解这样的写法那么可以先这样写for(var i=0;i","categories":[],"tags":[]},{"title":"欠债还钱系列（1—）Enumberable是什么？","slug":"欠债还钱系列（1—）Enumberable是什么？","date":"2017-03-22T12:58:19.000Z","updated":"2017-03-22T13:29:35.209Z","comments":true,"path":"2017/03/22/欠债还钱系列（1—）Enumberable是什么？/","link":"","permalink":"http://yoursite.com/2017/03/22/欠债还钱系列（1—）Enumberable是什么？/","excerpt":"","text":"欠债还钱，天经地义哟。今天就来还债咯，最近一直在准备实习生的笔试（不要问我为啥不直接面试，简历写的可能比较烂23333）。然后前几天的时候刷到的这个东西，刚看的时候觉得一脸懵逼什么鬼？？不得不说MDN是个好东西（吃我一波安利），好了废话差不多了，来点干货。 枚举对于大多数人入门前端之后的人来讲可能是经常会用到的一种东西，但是你真的了解它吗？而对于这些对象的属性，其实JS内部内置了一些方法来获取，或者是判断对象的一组或者一个属性。那么Enmberable就属于这个系列了。这个差不多就是介绍了，可能你看了会一脸懵逼，WTF???而Enumberable属于影响属性遍历的特性，如果这个值为true，证明是可枚举的，否则表明是不可以枚举的。Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组,但不会获取原型链上的属性。该数组对元素是 obj 自身拥有的枚举或不可枚举属性名称字符串，数组中枚举属性的顺序与通过for…in（或 Object.keys()）迭代该对象属性时一致。 数组中不可枚举属性的顺序未定。for…in()操作的主要目的就是遍历对象的属性而且还可以使用hasOwnProperty()进行过滤。对于不可枚举的属性也可以通过propertyIsEnumerable()方法进行检测。深入的研究还没怎么做，这个大概就是个人的理解了。 参考资料：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties","categories":[],"tags":[]},{"title":"笔试总结--新美大","slug":"笔试总结-新美大","date":"2017-03-21T14:05:32.000Z","updated":"2017-03-21T14:21:05.329Z","comments":true,"path":"2017/03/21/笔试总结-新美大/","link":"","permalink":"http://yoursite.com/2017/03/21/笔试总结-新美大/","excerpt":"","text":"因为师兄讲新美大还可以，不算顶尖的大公司，但是也没有很差所以就在前段时间内推了新美大的实习生，然后估计因为简历写的很烂，所以没接到电面。于是在刚刚做完了笔试，来总结一发。总体来说：很基础，但是其中考的还是很细的。第一里面考了很多的基础的算法复杂度的题，比如快排，堆排，冒泡，插入，大概就这四个。第二还考了跨域的问题，如何跨域，这个明天再写，现在还没研究明白。第三考的感觉有的地方还是有点偏(也有可能我自己的基础差)，常见的闭包，作用链，this,一个没考，印象比较深刻的是obj.enumerable相关的问题，这个我会再次开一篇讲一下自己学习之后的成果，然后还考了一些数据结构，比如二叉树。第四编程题很容易，但是前提是读的懂题目和要求。读了8分钟左右的题和预置代码，然后写思路，其实就是求两个数组的交集，然后以数组的形式输出这个交集，但是由于审题的时候被预置的几个参数搞蒙了，不过后来也是过了。第五还有就是http,DNS解析协议竟然也没考，计算机网络也没考，和我预想中的可能有点不一样。第六这次笔试比较奇怪的是HTML和css的知识也没怎么触及，可能是留在面试吧。 个人总结：基础还是不够细，总体来说个人的基础还是有很多的地方没复习到，接下来的一段时间主要是搞一搞基础的算法，然后梳理一下数据结构和操作系统的知识，。","categories":[],"tags":[]},{"title":"bootstrap页面草稿","slug":"bootstrap页面草稿","date":"2017-03-15T13:39:51.000Z","updated":"2017-03-15T13:48:06.831Z","comments":true,"path":"2017/03/15/bootstrap页面草稿/","link":"","permalink":"http://yoursite.com/2017/03/15/bootstrap页面草稿/","excerpt":"","text":"我这个low比，又来了，改版的话主页写了一点了，用刚刚学了2天的搞了一个粗糙的页面，色没调，图也没插，不过的确bootstrap是很好用的。差不多就是这样了。下面还想写点表单，但是还没想好加点什么，然后最近也在学ajax,看看能不能加上去，然后虽然是bootstrap写的，但是好像移动端调试的时候，还是问题很大，慢慢改吧，然后中午还看了点node.js+express+mongoDB搭建后台的文章，也在想看看能不能把后台也更新一下。","categories":[],"tags":[]},{"title":"“说出来你可能不信（2），bootstrap贼好用（1）？”","slug":"“说出来你可能不信（2），bootstrap贼好用？”","date":"2017-03-13T12:58:37.000Z","updated":"2017-03-13T13:26:17.225Z","comments":true,"path":"2017/03/13/“说出来你可能不信（2），bootstrap贼好用？”/","link":"","permalink":"http://yoursite.com/2017/03/13/“说出来你可能不信（2），bootstrap贼好用？”/","excerpt":"","text":"说出来你可能不信，对于我这种立志走数据向的前端来讲，最近自己在重构自己很久很久以前写的捞比网页的时候，我发现自己设计网页是极其不靠谱的。画了两晚上，就搞出个结构图，然后试了试，写了一点，自己都觉得自己什么鬼……。我能怎么办，不过后来我google出来一个东西叫bootstrap的东西，按照自己的结构图写了一点，觉得还不错哎。大概就是这个样子吧，可能大部分人觉得还是很丑，不过对比一下大概感觉就会觉得第一个神TM的漂亮。所以bootstrap对于一个没有设计师的团队来讲其实是很有用的。说到bootstrap，那么核心的思想，个人感觉就是css进行了封装，然后给一个接口给你用，而且还提供自己改版的机会（如果你懂less或者sass的话），简直不要太赞了。那么详细来说一下bootstrap吧，bootstrap个人感觉形式和JQuery是很像的，都是通过一些选择器来操作的。bootstrap最赞的感觉还是3.0，完全重构之后基于响应式的，这对于一个入门之后迷茫的前端开发者来讲的确是快速的开发一个pc+移动端都适配的网页的不二选择。所以，现在个人也在磨这个东西。接下来也会不定期的分享自己的踩坑历程。注：本人也是刚刚入门的小前端，如果哪里不对，欢迎各位大大指正。啊嘞，我还是滚去改我的网页吧，乐观的话，月底应该网站的前端加后台就可以做的差不多了，到时候我会上线一下自己写的网页试试，虽然很简单，但是毕竟是自己的亲儿子。","categories":[],"tags":[]},{"title":"ajax怎么用？","slug":"ajax怎么用？","date":"2017-03-10T13:10:39.000Z","updated":"2017-03-10T13:45:12.566Z","comments":true,"path":"2017/03/10/ajax怎么用？/","link":"","permalink":"http://yoursite.com/2017/03/10/ajax怎么用？/","excerpt":"","text":"AJAX是什么？全称：Asynchronous Javascript and XML(异步的加载js和XML技术)。为什么要用AJAX?使用ajax之后，当向服务器发送请求的时候不必发生等待结果，而是可以做其他的事情，等到有了结果他会自己根据设定进行后续的操作，与此同时页面不会发生整个页面刷新的也就是进一步提高了用户的体验。AJAX怎么实现异步加载的？（1）创建XMLHttpRequest对象，即创建一个异步调用的对象，而这个对象也是下面所有操作的基础。（2）创建一个新的http请求，并且指定该http请求的方法,url以及验证信息。（3）设置相应http请求变化的函数。（4）发送http请求（5）获取异步调用数据（6）使用js和Dom进行局部的刷新。 show the codefunction createXHR(){ if(typeofXMLHttpRequest!=”undefined”){ return new XMLHttpRequest();}else if(typeof ActiveObject!=’undefined’){ if(typeof arguments.callee.activeXString!=”string”){ var version=[“MSXML2.XMLHttp.6.0”,”MSXML2.XMLHttp.3.0”,”MSXML2.XMLHttp”],i,len; for(i=0,len=versions.length ;i&lt;length;i++){ try{new ActiveXobject(versons[i]); arguments.callee.activeXString=version[i]; break;}catch(ex){ //这里拿来写异常抛出吧 } }}}else { throw new Error(“No XHR object available.”);} }上面的是函数检测，没办法，我能怎么办，我也很绝望，这个东西不检测就可能没办法去适应ie7,兼容性检测，虽然很让人蛋疼，但是还是得做。先写到这吧，下面还有很多，慢慢的写。","categories":[],"tags":[]},{"title":"说出来你可能不信系列（1）原型链到底什么鬼？","slug":"说出来你可能不信系列（1）原型链到底什么鬼？","date":"2017-03-02T12:58:39.000Z","updated":"2017-03-04T10:35:59.120Z","comments":true,"path":"2017/03/02/说出来你可能不信系列（1）原型链到底什么鬼？/","link":"","permalink":"http://yoursite.com/2017/03/02/说出来你可能不信系列（1）原型链到底什么鬼？/","excerpt":"","text":"说出来你可能不信，虽然撸过一遍js高程设计，但是很多的地方还是不懂，比如原型链，也即是js继承的实现方式。JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。原型链的结尾成为null，而null被规定是没有prototype属性的，所以当你搜索到null的时候你的原型链也就到头了。一个简单的例子var z={ a:5, m:function add(){ return this.a+1;}}console.log(z.m());//6z–&gt;Object.prototype—&gt;null;var f=Object.create(z);f.a=10;console.log(z.m());//11f–&gt;z找到了就返回相应的函数，找不到就继续找。这个就是最简单地原型链了。1 #使用普通的方法的创建对象function zz(){ return 2;}zz–&gt;function.prototype—&gt;Object.prototype–&gt;null; #使用构造器构造函数(我现在还很晕，就先不写了)； #使用Object create创建对象var a{ a:”wo qis shi hen shuai”}var b=Object.create(a);b-&gt;a-&gt;object.prototype-&gt;null;2在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。,所以尽量先用hasOwnProperty来检验一下。","categories":[],"tags":[]},{"title":"js的变量的作用域","slug":"js的变量的作用域","date":"2017-03-01T03:34:46.000Z","updated":"2017-03-01T04:29:04.931Z","comments":true,"path":"2017/03/01/js的变量的作用域/","link":"","permalink":"http://yoursite.com/2017/03/01/js的变量的作用域/","excerpt":"","text":"1 js 当中存在着作用域链 （1) 当函数受到调用需要进行变量的调用的时候，会先到最内层的函数去找。 如果找到了就直接输出，最内层的函数。 如果没有找到，那么去外层函数找，找到了，输出外层函数定义的变量。 如果还是没有找到，那么就去找整个函数外层的变量，如果还没找到，就会报错var ss=1;function ts(){ var ss=3; function inner(){ var ss=2; console.log(“输出你需要的值”+ss); } inner();}ts();输出你需要的值2这就是正确的输出，如果你存在什么疑问的话，可以尝试注释掉不同的文件，来检验到底对不对。2 js当中没有块级作用域学过一点java的人应该都知道块级作用域是什么意思，如果你没学过，那也没关系。你可以简单的认为，两个花括号之间就是一个块级作用域。function test() { for (var i=0;i&lt;2;i++){ } console.log(i);}test();如果你学过java一定知道，这个肯定会报错。但是在js里面却没有，而且输出了结果2.js不支持块级作用域，只支持函数作用域，而且很神奇的事情是你可以在一个函数内部的任何地方定义一个变量，而在这个函数的内部都可以访问到（如果不考虑嵌套函数的话） 嵌套函数会在闭包中仔细谈，现在可以忽略一下。3 如何创建块级作用域说出来你可能不信，很多情况下，我们的的确确是需要块级作用域的，但是这时候该怎么办？unction test(){ (function (){ for(var i=0;i&lt;2;i++){ } // console.log(i); })(); console.log(); }test();来来走两步，没事儿你再来走两步。运行之后，会报错，但是把第二个console注释，然后取消第一个的注释，结果就会出来了。这里就应用了闭包的概念，所以单独的拿出来谈闭包是没有什么意义的。","categories":[],"tags":[]},{"title":"在使用git过程中出现的问题","slug":"在使用git过程中出现的问题","date":"2017-02-27T13:46:48.000Z","updated":"2017-03-01T04:30:28.744Z","comments":true,"path":"2017/02/27/在使用git过程中出现的问题/","link":"","permalink":"http://yoursite.com/2017/02/27/在使用git过程中出现的问题/","excerpt":"","text":"在使用git推到github上面就出现了问题比如Reinitialized existing Git repository in c:/xampp/htdocs/website/.git/ 这样的问题我个人写的时候也出现了，主要是写了两次git init当然也有可能是其他的问题，暂时还没遇到，遇到了之后我会在持续的更新这个帖子的","categories":[],"tags":[]},{"title":"怎么推自己的项目到github","slug":"怎么推自己的项目到github","date":"2017-02-27T13:00:24.000Z","updated":"2017-02-27T13:44:29.267Z","comments":true,"path":"2017/02/27/怎么推自己的项目到github/","link":"","permalink":"http://yoursite.com/2017/02/27/怎么推自己的项目到github/","excerpt":"","text":"说来也简单，但是对于刚刚入门的萌新来讲，其实还是有点难度的。1如果你是第一次使用的话，那么强烈建议你去http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000个人诚心推荐，如果有能力的话，去阅读以下官方的文档也是很不错的。 （1）如果你已经10天前推过一次自己的项目，10天后建立了一个新的项目又来推，你发现你自己忘了怎么推了。 即刚刚在自己的github上建立的项目还开始没把本地上的项目开始推 （1）git init 在某一个目录下你就可以初始化空的git仓库完毕了（.git文件不用工具的话是看不见的） （2）git add READEME.md(如果你没有在github初始化时添加) 如果添加了的话可以跳过这一步直接到（3） （3） git add . 这个就是添加你所在文件中的所有的东西不论格式怎么样 当然也可以添加其他的格式 如 git add a.txt这个就是说添加一个名字叫a.txt的文件 （4）git commit -m “你所做的修改” 双引号里面的就是你对文件所做的修改 （5）git remote add origin git@github.com:blackcloud2333/ex.git 添加一个叫origin的远程仓库 （6）git push -u origin master 将本地的更改推送到远程的分支。 （7）然后就可以去自己的github上看到实际的效果了","categories":[],"tags":[]},{"title":"hexo搭建过程中出现的问题","slug":"hexo搭建过程中出现的问题","date":"2017-02-26T10:42:19.000Z","updated":"2017-02-26T12:06:11.413Z","comments":true,"path":"2017/02/26/hexo搭建过程中出现的问题/","link":"","permalink":"http://yoursite.com/2017/02/26/hexo搭建过程中出现的问题/","excerpt":"","text":"1 在改变_config_yml的时候，要注意，字和前面的目录之间不能有空格否则就会出现下面的这种情况 出现这种情况之后，请到相应的位置，并做修改，如果不行可以考虑注释掉出问题的那一行，然后在$ hexo s 试一下。 2TypeError: The header content contains invalid characters 在安装的过程当中还出现了这个问题 解决的方法如下：https://github.com/hexojs/hexo/issues/1746当你 在 _config_yml（首页的而不是themes当中的）进行了设置时候，尤其是改变 副标题（subtitle)之后就可能会出现这个问题具体的原理其实我现在也还没弄清楚，但是感觉是hexo sever 有点问题。经过安装HTTP-sever之后没问题了3 还有就是下面的这种问题 这种问题一般来说是没有按规则先进行 hexo new “文章标题” 而你自己写了markdown，没有引入文章的头部 &lt;!–title: hexo搭建过程中出现的问题date: 2017-02-26 18:42:19tags:—-&gt; 所以会引起相关的问题","categories":[],"tags":[]}]}